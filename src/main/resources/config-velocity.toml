# UUID Swapper by ItsTauTvyDas.

# Database used to database player data such as fetched online UUID or saved randomized username/UUID!
[database]
    enabled = false
    # Automatically download SQLite JDBC driver
    download-driver = true
    # You can also specify download URL, the final file will be renamed to driver's name!
    #download-link = "https://domain.com/driver.jar"
    # SQLite JDBC is the only driver supported, I'm keeping this setting in case it's going to be implemented in the future.
    driver = "SQLite"
    file = "players-data.db"
    timeout = 5000
    # Keep the database connection open for 10 seconds.
    # If something gets requested from the database, the time counter will reset.
    # If set to -1, connection will always be kept and 0 - will always initiate new connection on request
    keep-open-for = 10
    # Database connection keep-alive check repeat (seconds).
    # This has no effect if 'keep-open-for' is set below 0 or below.
    timer-repeat-time = 1
    # Show when the connection was opened, close and when data was requested.
    debug = true

# Use online UUIDs for non-premium players
# If the server is in online mode, enabling this will allow offline players to join!
[online-uuids]
    enabled = false
    # Set to true if you still want to swap UUIDs even when always-use-online-uuids is enabled.
    swap-uuids = true
    # Choose which service to use to fetch online player's UUID.
    # Predefined available options:
    #   PlayerDB (https://playerdb.co/)
    #   MinecraftServices (https://api.minecraftservices.com)
    use-service = "PlayerDB" # Misspell will be treated as if online UUIDs are not enabled!
    fallback-services = [ "MinecraftServices" ]
    fallback-service-remember-time = 21600 # 6 hours defined in seconds
    # If defined service in 'use-service' fails, then fallbacks-services is used (one by one if let's say first fails).
    # Every service used in the process to get UUID, its timeout will add up to a number,
    # and if that number exceeds max-timeout, then the player will get disconnected.
    max-timeout = 6000
    min-timeout = 1000
    # Check if player's UUID uppon joining is online, if so, skip online UUID fetching
    check-for-online-uuid = true
    # Send successful messages to console, if a service has debug enabled, this is overriden!
    send-messages-to-console = true
    send-error-messages-to-console = true # Warnings are counted too.
    # If player connects second time and 2 seconds haven't passed, then they won't be allowed in the server.
    # Connection throttle does not affect when switched to fallback services.
    service-connection-throttle = 5000 # Set to 0 to disable
    service-connection-throttled-message = "UUID service connection throttles, wait {time-left} seconds until you can connect again!"
    # Show wait dialog for the player (!!! Only works for 1.21.6 players and up !!!)
    [online-uuids.connection-throttle-dialog]
        enabled = false
        dynamic = true # If true, placeholder {time-left} in seconds will be available.
        title = "UUID service connection throttled!"
        # If the message is not defined, 'service-connection-throttled-message' is used instead!
        message = "{time-left} seconds left until you can connect again!"
        # Show a translatable disconnect message.
        button = "::{menu.disconnect}"
        button-location = "TOP" # or BOTTOM.
    [online-uuids.caching]
        # If the database fails to initialize or connect, the cache won't be saved or used!
        enabled = true # Enable this to cache online UUIDs
        keep = 7200 # Keep online UUID cache for 5 days (in minutes)
        # These settings will only apply on table creation time!
        use-created-at = true
        use-updated-at = true
    [online-uuids.username-changes]
        # Caching must be enabled for this to work!
        check-depending-on-ip-address = false
        # Do not send a request to the service if the player's username is already in the database.
        no-requests-with-existing-username = true
    # Whatever is specified here, will get copied over to all services, unless it's already specified.
    [online-uuids.service-defaults]
        expect-status-code = 200 # Optional, default is 200
        # Placeholders: (available in the most messages)
        #   {response.<json path>} - get value from JSON (only available if response body is JSON)
        #       JSON values that are null will get converted to "[null]".
        #   {translatable:<translatable key>} - show a translatable key to the player
        #   {translatable:<translatable key>,<text/placeholder>,...} - if the translatable message contains an argument (%s), you can replace it with this format
        #   {response} - response's body (only available if response is text-based)
        #   {http.status} - returned HTTP status code.
        #   {http.url} - service endpoint's URL.
        #   {http.header.str.<header name>} - get header's value.
        #   {http.header.raw.<header name>} - get header's value.
        #   {username} - player's username.
        #   {uuid} - player's original UUID.
        #   {new-uuid} - player's fetched UUID.
        #   {error.class} - get full exception's class.
        #   {error.class-name} - get simple exception's class.
        #   {error.message} - get exception's message.
        #   {took} - how many milliseconds it took to send and receive data.
        #   {max-timeout} - max timeout from configuration.
        #   {min-timeout} - min timeout from configuration.
        #   {timeout-sounter} - same as {took} but including the fallbacks too.
        #   {timeout-left} - how many milliseconds are left for other fallbacks.
        bad-uuid-disconnect-message = "<red>Failed to get your online UUID (bad UUID), contact server's administrator!"
        default-disconnect-message = "<red>Failed to get your online UUID" # If this is not defined, multiplayer.disconnect.generic message is used.
        connection-error-disconnect-message = "<red>Failed to get your online UUID (connection error), contact server's administrator!"
        service-bad-status-disconnect-message = "<red>Failed to get your online UUID (service returned {http.status}), contact server's administrator!"
        unknown-error-disconnect-message = "<red>Failed to get your online UUID (unknown error), contact server's administrator!"
        service-timeout-disconnect-message = "<red>Failed to get your online UUID (service timed out), try again later!"
        timeout = 3000 # 3 seconds
        allow-caching = true # Optional, default is true.
        [online-uuids.service-defaults.use-fallbacks] # Define when the service should fall back to the next service in case of failure, disconnect otherwise.
            on-connection-error = true # When unknown connection error appears.
            on-invalid-uuid = true # When failed to parse UUID string.
            on-bad-uuid-path = true # When json-path-to-uuid was not found or is incorrect.
            on-unknown-error = true # When unhandled exception appears.
            on-bad-status = true # When service's HTTP status code is not what configuration expected.
        [online-uuids.service-defaults.headers]
            Accept = "application/json"
    [[online-uuids.services]]
        name = "example" # You can use the name in "use-service" setting, keep this unique, or it will get overwritten.
        endpoint = "https://your-service.com/get-uuid/{username}"
        # Supported methods: GET, POST.
        # If mispelled, GET will be used!.
        request-method = "GET" # Optional, default is GET.
        # If the service returns plain text, leave this empty.
        # Examples how to write the path depending on what JSON looks like:
        #   "UUID" -> "" (empty string)
        #   ["UUID"] -> "[0]" (empty string)
        #   {"key": "UUID"} -> "key"
        #   {"key": {"key2": "UUID"}} -> "key.key2"
        #   {"key": ["UUID"]} -> "key[0]"
        #   {"key": [{"key2": "UUID"}]} -> "key[0].key2"
        json-path-to-uuid = "path.to[0].uuid" # Optional, default is ""
        # Choose one of the settings below, can't be both.
        json-path-to-properties = "path.to.properties" # Optional, expected JSON is [{'name' : '...', 'value': '...', 'signature': '...'},...]
        json-path-to-textures = "path.to.textures" # Optional, expected JSON is {'name' : '...', 'value': '...', 'signature': '...'}
        # Sends debug messages to console.
        debug = false # Optional, default is false.
        # If response handlers are not defined and the plugin fails to find the UUID, it will not allow the player to join!
        # Handlers get executed depending on the specified order (random otherwise) and checks if at least one of the handlers allows the player to join.
        [[online-uuids.services.response-handlers]]
            # Since TOML configuration uses HashMap to store keys and values, it's not garuntee to be in order.
            # If two handlers have the same order number, the placement might be random!
            # The default internal value is 9999, executing is in ascending order
            order = 1
            # When to execute this handler. Availabled values:
            #   BEFORE_UUID - execute before UUID fetching
            #   AFTER_UUID - execute after UUID was successfully fetched
            #   AFTER_REQUEST - execute when service response is available
            #   ON_FALLBACK - execute when fallback service is used
            #   ON_DISCONNECT - execute when a player is about to disconnect (not by other handlers!)
            #   ON_CONNECT - execute when a player is about to connect (not by other handlers!)
            state = "AFTER_UUID" # Optional, default is AFTER_UUID.
            forcefully-allow-player-to-join = true # Optional, default is false.
            use-fallback = true # Optional, undefiend by default. If defined, then 'use-fallbacks' options are ignored!
            apply-properties = true # Optional, default is true. Should profile properties be applied to the player?
            disconnect-message = "Disconnected" # Optional. Send a custom disconnect message if allow-player-to-join is set to false.
            ignore-status-code = false # Optional, default is false. Ignores status code check, this allows to do more response handling
            # Conditions modes:
            # "OR" - at least one of the specified conditions have to match.
            # "AND" - all the specified conditions have to match.
            conditions-mode = "AND" # Optional, default is "AND".
            ignore-conditions-case = false # Optional, default is false
            [online-uuids.services.response-handlers.conditions]
                # Placeholders are also allowed in value place.
                # If a placeholder returns "value", then this handler will decide if player is
                # allowed to join based on "allow-player-to-join" setting.
                "placeholder" = "value"
                # To check if key exists, use '::' prefix
                "::response.path.to[1].json" = true
                # If you want to compare it to a boolean, use quotes
                "response.json.path" = "true"
        [online-uuids.services.post-data] # Optional.
            #key = "value"
        [online-uuids.services.query-data] # Optional.
            #key = "value"
        [online-uuids.services.headers] # Optional.
            #SomeHeader = "Value"
    [[online-uuids.services]]
        name = "PlayerDB"
        endpoint = "https://playerdb.co/api/player/minecraft/{username}"
        json-path-to-uuid = "data.player.id"
        json-path-to-properties = "data.player.properties"
        ignore-status-code = true
        [[online-uuids.services.response-handlers]]
            # Allow player to join with server's generated UUID if username is not tied to any premium account.
            forcefully-allow-player-to-join = true
            [online-uuids.services.response-handlers.conditions]
                "response.code" = "minecraft.invalid_username"
    [[online-uuids.services]]
        name = "MinecraftServices"
        endpoint = "https://api.minecraftservices.com/minecraft/profile/lookup/name/{username}"
        json-path-to-uuid = "id"
        ignore-status-code = true
        [[online-uuids.services.response-handlers]]
            forcefully-allow-player-to-join = true
            [online-uuids.services.response-handlers.conditions]
                "::response.errorMessage" = true
                #"response.errorMessage" = "Couldn't find any profile with name {username}"

# Randomize usernames or uuids on join.
# If this is enabled together with random UUID, online UUIDs will get disabled!
[randomizer]
    enabled = false
    [randomizer.username]
        randomize = true
        save = false
        characters = "qwertyuiopasdfghjklzxcvbnmQWERTYUIOPASDFGHJKLZXCVBNM123456789_"
    [randomizer.uuid]
        randomize = true
        save = false

# Force offline mode, only works if the server is in online mode!.
# Players that try to log in with premium accounts will have their online UUID.
# In exceptions, UUID will depend on if a player has a premium account or no.
[forced-offline-mode]
    enabled = false
    forced-by-default = true
    exceptions = [
        #"u:ItsTauTvyDas"
        #"cfe17913-ebc3-3cfb-9162-99908590f8f2"
    ]

# UUID swapping.
[swapped-uuids]
    #"u:ItsTauTvyDas" = "96642c39-6de2-3b20-a133-b354dcc36016"
    #"cfe17913-ebc3-3cfb-9162-99908590f8f2" = "aacb3ea4-8b3d-3830-8dc0-11a765a0de3a"

# Set custom player names.
# If you use UUID that has been previously swapped, use here the original.
[custom-player-names]
    #"96642c39-6de2-3b20-a133-b354dcc36016" = "Herobrine"
    #"u:Steve" = "Steve1"